# Zog.js v0.4.8 — Minimal Reactive UI Library

Zog.js is a lightweight (~5KB) Vue-inspired reactive framework for small/medium projects.
No build step required. Just include and use.

**This document helps LLMs generate correct Zog.js code.**

---

## Core Concepts

### Data Types
- `ref(primitive)` — For primitive values only (string, number, boolean)
- `reactive(object|array)` — For objects and arrays (deep reactivity)
- `computed(getter)` — Cached derived values

**IMPORTANT:** ref() throws error if passed object/array. Use reactive() instead.

---

## API Reference

### Reactivity
```javascript
import { ref, reactive, computed, watchEffect } from './zog.js';

// ref - primitives only
const count = ref(0);
count.value++;              // Use .value in JS

// reactive - objects/arrays
const state = reactive({ name: 'John', items: [] });
state.name = 'Jane';        // Direct access
state.items.push('item');   // Array methods work

// computed - cached
const double = computed(() => count.value * 2);
console.log(double.value);  // Use .value to read

// watchEffect - auto-tracking
const stop = watchEffect(() => console.log(count.value));
stop(); // cleanup
```

### Application
```javascript
import { createApp, nextTick } from './zog.js';

createApp(() => ({
  count: ref(0),
  items: reactive([]),
  increment() { this.count.value++ }
}))
.use(plugin, options)  // optional plugins
.mount('#app');

nextTick(() => { /* after DOM update */ });
```

### Hooks
```javascript
import { onHook } from './zog.js';

onHook('beforeCompile', (el, scope, cs) => {});
onHook('afterCompile', (el, scope, cs) => {});
onHook('onError', (err, type, context) => {});
```

---

## Template Syntax

### Interpolation
```html
{{ count }}                    <!-- auto-unwraps refs -->
{{ user.name }}                <!-- reactive object access -->
{{ price * qty }}              <!-- expressions -->
{{ active ? 'Yes' : 'No' }}    <!-- ternary -->
```

### Directives

#### z-if / z-else-if / z-else
```html
<div z-if="score >= 90">A</div>
<div z-else-if="score >= 80">B</div>
<div z-else>C</div>
```

#### z-for
```html
<!-- Basic -->
<li z-for="item in items">{{ item }}</li>

<!-- With index -->
<li z-for="(item, index) in items">{{ index }}: {{ item.name }}</li>

<!-- With key (recommended) -->
<li z-for="item in items" :key="item.id">{{ item.name }}</li>
```

**z-for behavior:**
- `item` is reactive object (direct access) or ref-wrapped primitive
- `index` is plain number, updates when array changes
- Both auto-unwrap in templates (no .value needed)
- Always use `:key` with unique ID for performance

#### z-model (two-way binding)
```html
<input z-model="name" />
<textarea z-model="bio"></textarea>
<input type="checkbox" z-model="agreed" />
<input type="radio" z-model="color" value="red" />
<select z-model="country">
  <option value="us">USA</option>
</select>
```

#### z-show / z-text / z-html
```html
<div z-show="isVisible">Toggle display</div>
<p z-text="message"></p>
<div z-html="htmlContent"></div>  <!-- XSS risk! -->
```

#### Attribute Binding (:attr)
```html
<img :src="imageUrl" />
<button :disabled="isLoading">Submit</button>
<div :class="{ active: isActive, error: hasError }">...</div>
<div :class="'btn ' + type">...</div>
<div :style="{ color: textColor, fontSize: size + 'px' }">...</div>
```

#### Event Handling (@event)
```html
<button @click="handleClick">Method</button>
<button @click="count.value++">Inline (need .value)</button>
<button @click="items.push('new')">Array method</button>
<input @input="onInput" @blur="onBlur" />
```

**Event handler rules:**
- Method name: `@click="methodName"` — called with event
- Inline expression: `@click="count.value++"` — refs need `.value`
- Event object available as `e`: `@click="handle(e)"`

---

## Complete Example

```html
<div id="app">
  <h1>{{ title }}</h1>
  
  <input z-model="newTodo" @keyup.enter="addTodo" />
  <button @click="addTodo">Add</button>
  
  <ul>
    <li z-for="(todo, index) in todos" :key="todo.id">
      <input type="checkbox" 
             :checked="todo.done" 
             @change="toggleTodo(todo.id)" />
      <span :class="{ done: todo.done }">
        {{ index + 1 }}. {{ todo.text }}
      </span>
      <button @click="removeTodo(todo.id)">×</button>
    </li>
  </ul>
  
  <p z-show="todos.length === 0">No todos yet!</p>
  <p>Total: {{ todos.length }} | Done: {{ doneCount }}</p>
</div>

<script type="module">
import { createApp, ref, reactive, computed } from './zog.js';

createApp(() => {
  const title = ref('My Todos');
  const newTodo = ref('');
  const todos = reactive([]);
  let nextId = 1;
  
  const doneCount = computed(() => 
    todos.filter(t => t.done).length
  );
  
  function addTodo() {
    if (!newTodo.value.trim()) return;
    todos.push({ id: nextId++, text: newTodo.value, done: false });
    newTodo.value = '';
  }
  
  function removeTodo(id) {
    const idx = todos.findIndex(t => t.id === id);
    if (idx > -1) todos.splice(idx, 1);
  }
  
  function toggleTodo(id) {
    const todo = todos.find(t => t.id === id);
    if (todo) todo.done = !todo.done;
  }
  
  return { title, newTodo, todos, doneCount, addTodo, removeTodo, toggleTodo };
}).mount('#app');
</script>
```

---

## Plugin System (v0.4.8)

### Overview

Zog.js provides a powerful hook-based plugin system that allows extending the framework's behavior without modifying the core. Plugins can intercept compilation, handle errors, and even prevent element rendering.

### Available Hooks

1. **`beforeCompile(el, scope, cs)`** - Called before an element is compiled
2. **`afterCompile(el, scope, cs)`** - Called after an element is compiled
3. **`onError(err, type, context)`** - Called when an error occurs

### Hook Return Values (v0.4.8 NEW!)

**Return `false`** - Stop compilation (beforeCompile only):
```javascript
onHook('beforeCompile', (el, scope, cs) => {
  if (el.hasAttribute('z-pre')) {
    el.removeAttribute('z-pre');
    return false; // ✅ Element will NOT be compiled
  }
});
```

**Return `undefined` or no return** - Continue normally (default behavior)

### Hook Parameters

```javascript
onHook('beforeCompile', (el, scope, cs) => {
  // el: DOM Node (nodeType 1=Element, 3=Text)
  // scope: Object - Reactive data for this scope
  // cs: Scope instance - Current compilation scope
});
```

#### `el` - DOM Node
```javascript
if (el.nodeType === 1) {
  // Element: <div>, <button>, etc.
  console.log('Tag:', el.tagName);
  console.log('Attrs:', [...el.attributes]);
}

if (el.nodeType === 3) {
  // Text node with possible {{ }} interpolation
  console.log('Text:', el.nodeValue);
}
```

#### `scope` - Reactive Data Object
```javascript
// Access reactive data
scope.counter?.value  // ref needs .value
scope.user?.name      // reactive direct access

// Call methods
if (typeof scope.methodName === 'function') {
  scope.methodName();
}
```

#### `cs` - Scope Instance
```javascript
cs.addEffect(stop);           // Register effect for cleanup
cs.addListener(el, ev, fn);   // Register event listener
cs.addChild(childScope);      // Register child scope
cs.cleanup();                 // Clean up everything
```

### Error Handling (v0.4.8 NEW!)

Hooks have automatic error handling:
- ✅ Error is logged to console
- ✅ `onError` hooks are triggered
- ✅ Other hooks continue to execute
- ✅ App doesn't crash

```javascript
api.onHook('onError', (err, type, context) => {
  console.error(`[${type}] Error:`, err.message);
  // Send to analytics, etc.
});
```

### Plugin API

```javascript
export const MyPlugin = {
  install(api, options) {
    // api contains:
    // - app, reactive, ref, computed, watchEffect
    // - onHook, compile, Scope, evalExp
    
    api.onHook('beforeCompile', (el, scope, cs) => {
      // Plugin logic here
    });
  }
};
```

### Complete Plugin Examples

#### Example 1: z-pre Plugin (Skip Compilation)

```javascript
/**
 * Prevents compilation of elements with z-pre attribute
 * Usage: <div z-pre>{{ not compiled }}</div>
 */
export const ZPrePlugin = {
  install(api) {
    api.onHook('beforeCompile', (el, scope, cs) => {
      if (el.nodeType !== 1) return;
      
      if (el.hasAttribute('z-pre')) {
        el.removeAttribute('z-pre');
        return false; // Stop compilation
      }
    });
  }
};
```

#### Example 2: Auto-focus Plugin

```javascript
/**
 * Auto-focuses elements with z-focus attribute
 * Usage: <input z-focus />
 */
export const FocusPlugin = {
  install(api) {
    api.onHook('afterCompile', (el, scope, cs) => {
      if (el.nodeType !== 1) return;
      
      if (el.hasAttribute('z-focus')) {
        el.removeAttribute('z-focus');
        setTimeout(() => el.focus(), 0);
      }
    });
  }
};
```

#### Example 3: Permission-based Rendering

```javascript
/**
 * Removes elements requiring permissions user doesn't have
 * Usage: <button z-permission="admin">Delete</button>
 */
export const PermissionPlugin = {
  install(api, options) {
    const { userPermissions = [] } = options;
    
    api.onHook('beforeCompile', (el, scope, cs) => {
      if (el.nodeType !== 1) return;
      
      const required = el.getAttribute('z-permission');
      if (!required) return;
      
      if (!userPermissions.includes(required)) {
        el.remove();
        return false; // Don't compile
      }
      
      el.removeAttribute('z-permission');
    });
  }
};

// Usage
createApp(() => ({}))
  .use(PermissionPlugin, { userPermissions: ['user', 'editor'] })
  .mount('#app');
```

#### Example 4: Responsive Rendering

```javascript
/**
 * Skip elements based on device type
 * Usage: <div z-mobile>Mobile only</div>
 */
export const ResponsivePlugin = {
  install(api) {
    const isMobile = /Android|iPhone/i.test(navigator.userAgent);
    
    api.onHook('beforeCompile', (el, scope, cs) => {
      if (el.nodeType !== 1) return;
      
      const mobileOnly = el.hasAttribute('z-mobile');
      const desktopOnly = el.hasAttribute('z-desktop');
      
      if ((mobileOnly && !isMobile) || (desktopOnly && isMobile)) {
        el.remove();
        return false;
      }
      
      el.removeAttribute('z-mobile');
      el.removeAttribute('z-desktop');
    });
  }
};
```

#### Example 5: Custom Directive (Tooltip)

```javascript
/**
 * Adds tooltip directive
 * Usage: <button z-tooltip="'Help text'">Hover</button>
 */
export const TooltipPlugin = {
  install(api) {
    const { watchEffect, evalExp } = api;
    
    api.onHook('beforeCompile', (el, scope, cs) => {
      if (el.nodeType !== 1) return;
      
      const tooltipExp = el.getAttribute('z-tooltip');
      if (!tooltipExp) return;
      
      el.removeAttribute('z-tooltip');
      
      // Create tooltip
      const tooltip = document.createElement('div');
      tooltip.className = 'tooltip';
      tooltip.style.cssText = `
        position: absolute;
        background: #333;
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        display: none;
        z-index: 9999;
      `;
      document.body.appendChild(tooltip);
      
      // Reactive text
      cs.addEffect(watchEffect(() => {
        tooltip.textContent = evalExp(tooltipExp, scope) || '';
      }));
      
      // Show/hide handlers
      const show = (e) => {
        tooltip.style.display = 'block';
        tooltip.style.left = e.pageX + 10 + 'px';
        tooltip.style.top = e.pageY + 10 + 'px';
      };
      const hide = () => tooltip.style.display = 'none';
      
      el.addEventListener('mouseenter', show);
      el.addEventListener('mousemove', show);
      el.addEventListener('mouseleave', hide);
      
      cs.addListener(el, 'mouseenter', show);
      cs.addListener(el, 'mousemove', show);
      cs.addListener(el, 'mouseleave', hide);
      
      // Cleanup
      cs.addEffect(() => tooltip.remove());
    });
  }
};
```

### Plugin Best Practices

✅ **DO:**
- Always check `el.nodeType` before processing
- Remove custom attributes after processing
- Register effects/listeners with `cs.addEffect()` / `cs.addListener()`
- Return `false` to stop compilation when needed
- Use options for configuration

❌ **DON'T:**
- Don't forget to remove attributes
- Don't modify elements after returning false
- Don't create memory leaks (use cs.addListener)
- Don't throw uncaught errors

### Plugin Installation

```javascript
import { createApp } from './zog.js';
import { Plugin1, Plugin2 } from './plugins.js';

createApp(() => ({ /* ... */ }))
  .use(Plugin1)                    // No options
  .use(Plugin2, { option: true })  // With options
  .mount('#app');
```

Plugins execute in registration order. If Plugin1's `beforeCompile` returns `false`, Plugin2's won't run for that element.

### Hook Capabilities Summary

| Hook | Can Stop Compilation? | Error Isolated? | Use Case |
|------|----------------------|-----------------|----------|
| beforeCompile | ✅ Yes (return false) | ✅ Yes | Skip/modify elements |
| afterCompile | ❌ No | ✅ Yes | Post-processing |
| onError | ❌ No | ✅ Yes | Error logging |

---

## Common Mistakes

### ❌ Using ref for objects
```javascript
const user = ref({ name: 'John' });  // ERROR! throws
const user = reactive({ name: 'John' });  // ✅ correct
```

### ❌ Using index for mutations
```html
<!-- WRONG: index changes after removal -->
<button @click="remove(index)">Delete</button>

<!-- CORRECT: use unique ID -->
<button @click="remove(item.id)">Delete</button>
```

### ❌ Missing .value in event handlers
```html
<!-- WRONG: refs not auto-unwrapped in events -->
@click="count++"

<!-- CORRECT -->
@click="count.value++"
@click="increment"  <!-- or use method -->
```

### ❌ Using index as key
```html
<!-- WRONG -->
<div z-for="(item, i) in items" :key="i">

<!-- CORRECT -->
<div z-for="item in items" :key="item.id">
```

### ❌ Forgetting .value in JS
```javascript
// WRONG
console.log(count);  // logs ref object

// CORRECT
console.log(count.value);  // logs number
```

---

## Quick Reference

| Context | ref access | reactive access |
|---------|-----------|-----------------|
| JavaScript | `count.value` | `state.name` |
| Template {{ }} | `count` (auto) | `state.name` |
| :attr binding | `count` (auto) | `state.name` |
| @event inline | `count.value` | `state.name` |
| @event method | `count.value` | `state.name` |

### When to use what
- **Primitive (string/number/boolean)** → `ref()`
- **Object or Array** → `reactive()`
- **Derived value** → `computed()`

### z-for item types
- **Object in array** → item is reactive, access `item.prop` directly
- **Primitive in array** → item is ref-wrapped, but auto-unwrapped in template

---

## Supported Array Methods

All these trigger reactivity:

**Mutators:** push, pop, shift, unshift, splice, sort, reverse, fill, copyWithin

**Iterators:** map, filter, find, findIndex, findLast, findLastIndex, includes, indexOf, lastIndexOf, some, every, forEach, reduce, reduceRight, flat, flatMap, values, entries, keys

---

**End of Zog.js v0.4.8 Reference**