# Zog.js (v0.3.0) — Minimal Reactive UI + DOM Compiler

Zog.js is a tiny reactive UI framework that compiles and binds a DOM subtree using directives and mustache-style interpolation. It provides:
- A reactive core (reactive/ref/computed/watchEffect)
- A DOM compiler (compile) that wires bindings to effects
- A small app wrapper (createApp) with cleanup + plugin/hooks

This file is written for LLMs and code assistants to generate correct Zog.js code.

---

## Public API (Exports)

Core reactivity:
- reactive(target): Deep reactive Proxy for objects/arrays
- ref(value): Reactive box with `.value`
- computed(getter): Lazy cached ref-like computed value (read-only)
- watchEffect(fn, opts?): Runs `fn` reactively, returns a stop() function
- nextTick(fn): Queue a microtask (Promise.then)

DOM/compiler & extensibility:
- compile(rootEl, scope, scopeController): Compile/bind a DOM subtree (advanced)
- createApp(setup): Create an app instance with `.use()`, `.mount()`, `.unmount()`
- addHook(name, fn), removeHook(name, fn): Hook system for compilation/effects/errors

NOTE:
- `compile()` is exported but intended as an advanced/internal API.
- Zog.js is an ES module; use `<script type="module">`.

---

## Quick Start

### HTML
<div id="app">
  <h1>{{ title }}</h1>
  <button @click="inc">Count: {{ count }}</button>

  <input z-model="name" placeholder="Type your name" />
  <p z-text="greeting"></p>

  <ul>
    <li z-for="item in items" :key="item.id">
      {{ item.label }}
      <button @click="removeItem(item.value.id)">remove</button>
    </li>
  </ul>

  <p z-if="count > 3">Count is big</p>
  <p z-else>Keep clicking…</p>
</div>

### JS (ES Module)
import { createApp, ref, reactive, computed } from "./zog.js";

createApp(() => {
  const title = ref("Hello Zog");
  const count = ref(0);

  const name = ref("");
  const items = reactive([
    { id: 1, label: "First" },
    { id: 2, label: "Second" }
  ]);

  const greeting = computed(() => `Hi, ${name || "friend"}!`);

  function inc() { count.value++; } // in JS, refs use .value
  
  // IMPORTANT: Use ID-based operations, not index-based
  function removeItem(itemId) { 
    const index = items.findIndex(item => item.id === itemId);
    if (index > -1) {
      items.splice(index, 1);
    }
  }

  return { title, count, name, items, greeting, inc, removeItem };
}).mount("#app");

---

## Reactivity Model

### ref(value)
- Returns `{ _isRef: true, get value(), set value() }`
- Use `.value` in normal JS code.

### reactive(objectOrArray)
- Deep reactive Proxy (nested objects/arrays become reactive)
- Arrays have special wrappers for mutators/iterators to trigger updates.

### computed(getter)
- Lazy: computed value is only evaluated on first access or when invalidated.
- Read-only (no setter).

### watchEffect(fn, { scheduler }?)
- Automatically tracks dependencies used inside `fn`.
- Re-runs when dependencies change.
- Returns stop() to cleanup.
- Effects are batched in a Promise microtask queue.

---

## Template Expressions: IMPORTANT REF UNWRAPPING RULE

Zog.js evaluates template expressions via an internal evaluator.

1) In template bindings/interpolations ({{ }}, :attr, z-text, z-show, z-for expressions, z-if expressions):
- Top-level scope refs are AUTO-UNWRAPPED.
- That means: use `{{ count }}` (NOT `{{ count.value }}`).

2) In inline event expressions (e.g. @click="count.value++"):
- Scope values are passed as-is (refs are NOT auto-unwrapped).
- If you write inline expressions that touch refs, use `.value` explicitly.

Recommendation:
- Prefer method handlers: `@click="inc"` where `inc()` updates refs safely.
- If you use inline code, use `.value` for refs.

---

## Directives & Syntax

### Interpolation
- Text nodes support: `Hello {{ expression }}`
- Expression is plain JS.

### Conditional Rendering
- z-if="expression"
- z-else-if="expression"
- z-else
Behavior:
- Branches are cloned as templates.
- Only the active branch is in the DOM and compiled.

### List Rendering
- z-for="item in items"
- z-for="(item, index) in items"
Also supports `of` as an alias for `in/of`.

Keyed lists:
- Use `:key="expression"` or `z-key="expression"`.
- Key expression is evaluated with `item` and `index` in scope.

**Important:** In z-for loops:
- `item` is wrapped in a ref (use `item.value` in event handlers)
- `index` is a plain number (use directly without `.value`)

**CRITICAL:** Always use item IDs for operations (delete, update, etc.), never use index! See "Best Practices for List Operations" below.

### Content / Visibility
- z-text="expression"   -> sets textContent (safe for HTML injection)
- z-html="expression"   -> sets innerHTML (TRUSTED content only)
- z-show="expression"   -> toggles `display: none`

### Two-way Binding
- z-model="pathOrRef"
Works with:
- input (text), textarea, select
- checkbox/radio (uses checked)
Notes:
- For ref targets: use `z-model="name"` where name is a ref
- For reactive paths: use `z-model="form.email"`

### Event Handling
- @click="handlerOrExpression"
- z-on:click="handlerOrExpression"
Rules:
- If the value matches a function in scope, it is called with (event).
- Otherwise it is treated as a JS statement and executed with `e` as the event variable.

Limitations:
- Event modifiers (e.g. @click.prevent, @keyup.enter) are NOT parsed/handled.

### Attribute Binding
- :attr="expression"       (e.g. :href, :title, :disabled)
- :class="expression"      supports string or object map
- :style="expression"      supports object map (Object.assign into el.style)

Also supported:
- z-src="expression", z-id="expression", z-disabled="expression", ...
  Any `z-<attr>` not equal to z-text/z-html/z-show maps to a DOM attribute `<attr>`.

Boolean attributes:
- If expression returns boolean: true => set attribute, false => remove it.

---

## createApp(setup)

createApp(setup) returns an app with:
- .use(plugin, options?)
- .mount(cssSelector)
- .unmount()

setup() must return the scope object containing:
- reactive state (reactive/ref/computed)
- methods (functions) referenced by events

Unmount:
- stops all effects and removes all event listeners registered by the compiler.

---

## Best Practices for List Operations

### Why You Should NEVER Use Index for Operations

**Problem:** Array indices change when items are added or removed.

```javascript
// ❌ WRONG - Using index (THIS WILL CAUSE BUGS!)
const todos = reactive([
  { id: 1, text: 'Task 1' },
  { id: 2, text: 'Task 2' },
  { id: 3, text: 'Task 3' }
]);

function removeTodo(index) {
  todos.splice(index, 1); // BUG: Wrong item gets removed after deletions!
}

function toggleTodo(index) {
  todos[index].completed = !todos[index].completed; // BUG: Wrong item gets toggled!
}
```

**What happens:**
1. User removes item at index 1
2. Item at index 2 becomes index 1
3. Next operation on "index 1" affects the wrong item!

### Correct Approach: Use Stable IDs

```javascript
// ✅ CORRECT - Using ID
const todos = reactive([
  { id: 1, text: 'Task 1', completed: false },
  { id: 2, text: 'Task 2', completed: false },
  { id: 3, text: 'Task 3', completed: false }
]);

function removeTodo(todoId) {
  const index = todos.findIndex(t => t.id === todoId);
  if (index > -1) {
    todos.splice(index, 1);
  }
}

function toggleTodo(todoId) {
  const todo = todos.find(t => t.id === todoId);
  if (todo) {
    todo.completed = !todo.completed;
  }
}
```

### Template Usage with IDs

**Remember:** In z-for, items are refs, so use `item.value.id` in event handlers:

```html
<!-- ✅ CORRECT -->
<div z-for="todo in todos" :key="todo.id">
  {{ todo.text }}
  <button @click="toggleTodo(todo.value.id)">Toggle</button>
  <button @click="removeTodo(todo.value.id)">Delete</button>
</div>

<!-- ❌ WRONG - Using index -->
<div z-for="(todo, index) in todos" :key="todo.id">
  {{ todo.text }}
  <button @click="toggleTodo(index)">Toggle</button> <!-- BUG! -->
  <button @click="removeTodo(index)">Delete</button> <!-- BUG! -->
</div>
```

### When Index is Acceptable

Index is ONLY safe for:
- **Display purposes**: `{{ index + 1 }}. {{ item.label }}`
- **Non-mutating operations**: Sorting, filtering (without modifying original array)
- **Temporary calculations**: Inside the template expression itself

**Never** pass index to functions that modify the array!

### Generating Unique IDs

```javascript
// Simple counter
let nextId = 1;
function addTodo(text) {
  todos.push({
    id: nextId++,
    text: text,
    completed: false
  });
}

// Or use timestamp + random
function generateId() {
  return Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}
```

---

## Minimal Patterns for LLMs

Good:
- Use methods for events: `@click="inc"`
- Use refs in JS with `.value`
- Use refs in templates without `.value`
- **Always use IDs for list operations**: `@click="removeItem(item.value.id)"`
- Display index safely: `{{ index + 1 }}. {{ item.name }}`

Avoid:
- `@click="count++"` (breaks if count is a ref)
- **`@click="removeItem(index)"` (causes bugs when items are removed!)**
- **Using index for any mutating operations**

Use:
- `@click="count.value++"` OR better: `@click="inc"`
- **`@click="removeItem(item.value.id)"` (stable, safe operations)**

---

## Plugin Development: Advanced Hook & Compilation Patterns

### Understanding Compilation Timing with z-if

CRITICAL: When z-if compiles:
1. Element is cloned as a template (cloneNode(true))
2. Hooks (beforeCompile/afterCompile) run on the TEMPLATE CLONE, not the final DOM element
3. The actual DOM element is inserted later when the condition becomes true
4. compile() is called on the inserted element, triggering hooks again

This means:
- `document.body.contains(el)` may be FALSE in beforeCompile/afterCompile hooks
- Direct DOM operations in hooks may fail if element isn't mounted yet
- Element references can become stale when z-if re-renders

### Hook Selection Strategy

**Use beforeCompile when:**
- You want to prevent default compilation (return false)
- You need to process attributes before core directives run
- You're implementing alternative compilation logic (z-once, z-pre)

**Use afterCompile when:**
- Element is guaranteed to be in DOM (not inside z-if)
- You need to observe/modify after full compilation

**For directives requiring DOM presence:**
Use watchEffect to detect when element enters DOM:
```javascript
addHook('beforeCompile', (el, scope, cs) => {
  if (el.hasAttribute('my-directive')) {
    el.removeAttribute('my-directive');
    
    let cleanup = null;
    cs.addEffect(watchEffect(() => {
      const inDOM = document.body.contains(el);
      
      if (inDOM && !cleanup) {
        // Setup: element is now in DOM
        cleanup = setupMyDirective(el);
      } else if (!inDOM && cleanup) {
        // Teardown: element removed from DOM
        cleanup();
        cleanup = null;
      }
    }));
    
    cs.addEffect(() => cleanup?.());
  }
});
```

### Working with z-if Elements in Plugins

**Problem:** Element references become invalid when z-if re-clones.

**Solution 1 - Use unique markers:**
```javascript
const uniqueId = 'my-dir-' + Math.random().toString(36).substr(2, 9);
el.setAttribute('data-my-marker', uniqueId);

// Later, find the real DOM element:
const realEl = document.querySelector(`[data-my-marker="${uniqueId}"]`);
if (realEl && realEl.contains(e.target)) { /* ... */ }
```

**Solution 2 - Use watchEffect with DOM checks:**
Don't cache element references. Always check `document.body.contains(el)` in event handlers.

### z-for Item and Index Behavior

**IMPORTANT:** z-for wraps items in ref() but index is a plain number:
```javascript
// Given:
const list = reactive([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);

// In template:
<div z-for="(item, index) in list">
  {{ item.name }}                   <!-- ✅ Works: auto-unwrapped in templates -->
  {{ index }}                       <!-- ✅ Plain number, no unwrapping needed -->
  @click="item.value.id"            <!-- ✅ item is a ref, use .value in events -->
  @click="doSomething(item.value.id)" <!-- ✅ Pass ID, not index! -->
  @click="showNumber(index)"        <!-- ✅ index is plain number (display only!) -->
  @click="update(item)"             <!-- ⚠️  item is { _isRef: true, value: {...} } -->
</div>
```

**Why?** z-for needs mutable references to update items when the list changes, but index is just a display value:
```javascript
// From zog.js:
const itemRef = ref(val);
const indexRef = index; // Plain number, not wrapped in ref
const s = new Scope({ ...scope, [itemName]: itemRef, [indexName]: indexRef });
```

**In plugin code:** If processing z-for scope:
- Items are refs: `const actualValue = item._isRef ? item.value : item;`
- Index is a plain number: use directly without `.value`
- **Always recommend using IDs for operations, not index**

### Ref Unwrapping Rules (Complete Reference)

**Template expressions (auto-unwrapped):**
- `{{ count }}` ✅
- `:disabled="isDisabled"` ✅
- `z-if="isVisible"` ✅
- `z-for="item in items"` ✅ (items unwrapped, but each item becomes ref)
- `z-for="(item, index) in items"` ✅ (index is plain number)
- `z-text="message"` ✅
- `:key="item.id"` ✅ (attributes auto-unwrap)

**Inline event handlers (NOT unwrapped for refs, but index is plain):**
- `@click="count++"` ❌ Breaks if count is ref
- `@click="count.value++"` ✅ Must use .value for refs
- `@click="item.name = 'x'"` ❌ If item is z-for item (it's a ref)
- `@click="item.value.name = 'x'"` ✅ Correct for z-for items
- `@click="doSomething(index)"` ⚠️ Only safe for display, NOT for mutations!
- `@click="removeItem(item.value.id)"` ✅ Use ID for operations

**Best practice:** Use method handlers to avoid confusion:
```javascript
@click="increment"  // where increment() { count.value++ }
@click="removeItem(item.value.id)" // Pass ID, handle lookup in method
@click="displayIndex(index)" // Safe for display purposes only
```

### Plugin Event Handler Processing

When processing event handlers in plugins, scope values are passed as-is:
```javascript
Function(...Object.keys(scope), 'e', `"use strict";${expression}`)
  (...Object.values(scope), e);
  // ⚠️ Object.values(scope) includes refs as { _isRef: true, value: ... }
  // ⚠️ But z-for index values are plain numbers
```

**Don't unwrap in plugins** unless you have a specific reason. Users should handle refs in their event code.

### Cleanup Patterns

Always register cleanup in scopeController:
```javascript
cs.addEffect(() => {
  // Cleanup function
  document.removeEventListener('click', handler, true);
});
```

For listeners:
```javascript
el.addEventListener('click', handler);
cs.addListener(el, 'click', handler);
// Scope cleanup will call el.removeEventListener automatically
```

### Common Plugin Pitfalls

1. **Assuming element is in DOM**: Always check `document.body.contains(el)`
2. **Caching element references**: They become stale with z-if
3. **Not handling cleanup**: Memory leaks from event listeners
4. **Unwrapping refs unnecessarily**: Let users handle .value in their code
5. **Using afterCompile for z-if elements**: Element may not be in DOM yet
6. **Treating z-for index as ref**: Index is a plain number, not a ref
7. **Recommending index-based operations**: Always recommend ID-based operations for list mutations

---

## Common Mistakes to Avoid

### 1. Using Index for Array Operations
```javascript
// ❌ WRONG
@click="removeItem(index)"

// ✅ CORRECT
@click="removeItem(item.value.id)"
```

### 2. Forgetting .value in Event Handlers
```javascript
// ❌ WRONG - In template attribute binding
:key="item.value.id"  // Attributes auto-unwrap!

// ✅ CORRECT - In template attribute binding
:key="item.id"

// ❌ WRONG - In event handler
@click="remove(item.id)"  // item is a ref in events!

// ✅ CORRECT - In event handler
@click="remove(item.value.id)"
```

### 3. Mixing Up Template vs Event Handler Rules
```javascript
// TEMPLATE EXPRESSIONS (auto-unwrap):
{{ item.name }}          // ✅ Correct
:disabled="item.active"  // ✅ Correct
:key="item.id"          // ✅ Correct

// EVENT HANDLERS (NOT auto-unwrapped):
@click="item.value.name"   // ✅ Correct
@click="toggle(item.value.id)" // ✅ Correct
```

### 4. Not Using Unique Keys
```javascript
// ❌ WRONG - No key or non-unique key
<div z-for="item in items">

// ❌ WRONG - Using index as key
<div z-for="(item, index) in items" :key="index">

// ✅ CORRECT - Using unique ID
<div z-for="item in items" :key="item.id">
```

---
