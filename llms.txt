# Zog.js v0.4.7 — Minimal Reactive UI Library

Zog.js is a lightweight (~5KB) Vue-inspired reactive framework for small/medium projects.
No build step required. Just include and use.

**This document helps LLMs generate correct Zog.js code.**

---

## Core Concepts

### Data Types
- `ref(primitive)` — For primitive values only (string, number, boolean)
- `reactive(object|array)` — For objects and arrays (deep reactivity)
- `computed(getter)` — Cached derived values

**IMPORTANT:** ref() throws error if passed object/array. Use reactive() instead.

---

## API Reference

### Reactivity
```javascript
import { ref, reactive, computed, watchEffect } from './zog.js';

// ref - primitives only
const count = ref(0);
count.value++;              // Use .value in JS

// reactive - objects/arrays
const state = reactive({ name: 'John', items: [] });
state.name = 'Jane';        // Direct access
state.items.push('item');   // Array methods work

// computed - cached
const double = computed(() => count.value * 2);
console.log(double.value);  // Use .value to read

// watchEffect - auto-tracking
const stop = watchEffect(() => console.log(count.value));
stop(); // cleanup
```

### Application
```javascript
import { createApp, nextTick } from './zog.js';

createApp(() => ({
  count: ref(0),
  items: reactive([]),
  increment() { this.count.value++ }
}))
.use(plugin, options)  // optional plugins
.mount('#app');

nextTick(() => { /* after DOM update */ });
```

### Hooks
```javascript
import { onHook } from './zog.js';

onHook('beforeCompile', (el, scope, cs) => {});
onHook('afterCompile', (el, scope, cs) => {});
onHook('onError', (err, type, context) => {});
```

---

## Template Syntax

### Interpolation
```html
{{ count }}                    <!-- auto-unwraps refs -->
{{ user.name }}                <!-- reactive object access -->
{{ price * qty }}              <!-- expressions -->
{{ active ? 'Yes' : 'No' }}    <!-- ternary -->
```

### Directives

#### z-if / z-else-if / z-else
```html
<div z-if="score >= 90">A</div>
<div z-else-if="score >= 80">B</div>
<div z-else>C</div>
```

#### z-for
```html
<!-- Basic -->
<li z-for="item in items">{{ item }}</li>

<!-- With index -->
<li z-for="(item, index) in items">{{ index }}: {{ item.name }}</li>

<!-- With key (recommended) -->
<li z-for="item in items" :key="item.id">{{ item.name }}</li>
```

**z-for behavior:**
- `item` is reactive object (direct access) or ref-wrapped primitive
- `index` is plain number, updates when array changes
- Both auto-unwrap in templates (no .value needed)
- Always use `:key` with unique ID for performance

#### z-model (two-way binding)
```html
<input z-model="name" />
<textarea z-model="bio"></textarea>
<input type="checkbox" z-model="agreed" />
<input type="radio" z-model="color" value="red" />
<select z-model="country">
  <option value="us">USA</option>
</select>
```

#### z-show / z-text / z-html
```html
<div z-show="isVisible">Toggle display</div>
<p z-text="message"></p>
<div z-html="htmlContent"></div>  <!-- XSS risk! -->
```

#### Attribute Binding (:attr)
```html
<img :src="imageUrl" />
<button :disabled="isLoading">Submit</button>
<div :class="{ active: isActive, error: hasError }">...</div>
<div :class="'btn ' + type">...</div>
<div :style="{ color: textColor, fontSize: size + 'px' }">...</div>
```

#### Event Handling (@event)
```html
<button @click="handleClick">Method</button>
<button @click="count.value++">Inline (need .value)</button>
<button @click="items.push('new')">Array method</button>
<input @input="onInput" @blur="onBlur" />
```

**Event handler rules:**
- Method name: `@click="methodName"` — called with event
- Inline expression: `@click="count.value++"` — refs need `.value`
- Event object available as `e`: `@click="handle(e)"`

---

## Complete Example

```html
<div id="app">
  <h1>{{ title }}</h1>
  
  <input z-model="newTodo" @keyup.enter="addTodo" />
  <button @click="addTodo">Add</button>
  
  <ul>
    <li z-for="(todo, index) in todos" :key="todo.id">
      <input type="checkbox" 
             :checked="todo.done" 
             @change="toggleTodo(todo.id)" />
      <span :class="{ done: todo.done }">
        {{ index + 1 }}. {{ todo.text }}
      </span>
      <button @click="removeTodo(todo.id)">×</button>
    </li>
  </ul>
  
  <p z-show="todos.length === 0">No todos yet!</p>
  <p>Total: {{ todos.length }} | Done: {{ doneCount }}</p>
</div>

<script type="module">
import { createApp, ref, reactive, computed } from './zog.js';

createApp(() => {
  const title = ref('My Todos');
  const newTodo = ref('');
  const todos = reactive([]);
  let nextId = 1;
  
  const doneCount = computed(() => 
    todos.filter(t => t.done).length
  );
  
  function addTodo() {
    if (!newTodo.value.trim()) return;
    todos.push({ id: nextId++, text: newTodo.value, done: false });
    newTodo.value = '';
  }
  
  function removeTodo(id) {
    const idx = todos.findIndex(t => t.id === id);
    if (idx > -1) todos.splice(idx, 1);
  }
  
  function toggleTodo(id) {
    const todo = todos.find(t => t.id === id);
    if (todo) todo.done = !todo.done;
  }
  
  return { title, newTodo, todos, doneCount, addTodo, removeTodo, toggleTodo };
}).mount('#app');
</script>
```

---

## Plugin System

```javascript
// my-plugin.js
export const MyPlugin = {
  install(api, options) {
    // api contains: app, reactive, ref, computed, watchEffect, 
    //               onHook, compile, Scope, evalExp
    
    api.onHook('beforeCompile', (el, scope, cs) => {
      if (el.hasAttribute('z-focus')) {
        el.removeAttribute('z-focus');
        setTimeout(() => el.focus(), 0);
      }
    });
  }
};

// Usage
import { createApp } from './zog.js';
import { MyPlugin } from './my-plugin.js';

createApp(() => ({ /* ... */ }))
  .use(MyPlugin, { debug: true })
  .mount('#app');
```

---

## Common Mistakes

### ❌ Using ref for objects
```javascript
const user = ref({ name: 'John' });  // ERROR! throws
const user = reactive({ name: 'John' });  // ✅ correct
```

### ❌ Using index for mutations
```html
<!-- WRONG: index changes after removal -->
<button @click="remove(index)">Delete</button>

<!-- CORRECT: use unique ID -->
<button @click="remove(item.id)">Delete</button>
```

### ❌ Missing .value in event handlers
```html
<!-- WRONG: refs not auto-unwrapped in events -->
@click="count++"

<!-- CORRECT -->
@click="count.value++"
@click="increment"  <!-- or use method -->
```

### ❌ Using index as key
```html
<!-- WRONG -->
<div z-for="(item, i) in items" :key="i">

<!-- CORRECT -->
<div z-for="item in items" :key="item.id">
```

### ❌ Forgetting .value in JS
```javascript
// WRONG
console.log(count);  // logs ref object

// CORRECT
console.log(count.value);  // logs number
```

---

## Quick Reference

| Context | ref access | reactive access |
|---------|-----------|-----------------|
| JavaScript | `count.value` | `state.name` |
| Template {{ }} | `count` (auto) | `state.name` |
| :attr binding | `count` (auto) | `state.name` |
| @event inline | `count.value` | `state.name` |
| @event method | `count.value` | `state.name` |

### When to use what
- **Primitive (string/number/boolean)** → `ref()`
- **Object or Array** → `reactive()`
- **Derived value** → `computed()`

### z-for item types
- **Object in array** → item is reactive, access `item.prop` directly
- **Primitive in array** → item is ref-wrapped, but auto-unwrapped in template

---

## Supported Array Methods

All these trigger reactivity:

**Mutators:** push, pop, shift, unshift, splice, sort, reverse, fill, copyWithin

**Iterators:** map, filter, find, findIndex, findLast, findLastIndex, includes, indexOf, lastIndexOf, some, every, forEach, reduce, reduceRight, flat, flatMap, values, entries, keys

---

**End of Zog.js v0.4.7 Reference**
